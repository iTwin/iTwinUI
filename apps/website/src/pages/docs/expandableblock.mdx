---
title: Expandable block
description: A pattern for progressive disclosure of information.
layout: ./_layout.astro
propsPath: '@itwin/itwinui-react/esm/core/ExpandableBlock/ExpandableBlock.d.ts'
thumbnail: ExpandableBlock
group: core
---

import PropsTable from '~/components/PropsTable.astro';
import LiveExample from '~/components/LiveExample.astro';
import RelatedComponents from '~/components/RelatedComponents.astro';
import * as AllExamples from 'examples';

<p>{frontmatter.description}</p>

<LiveExample src='ExpandableBlock.main.tsx' truncate={false}>
  <AllExamples.ExpandableBlockMainExample client:load />
</LiveExample>

The expandable block has a label reflecting its content. On click, it expands to reveal more content.

## Usage

The expandable block can be used in two ways:

- Directly using `ExpandableBlock` along with `title`, `caption`, `endIcon` and children. This pattern can suffice for simple cases.
- Using subcomponents (`ExpandableBlock.Wrapper`, `ExpandableBlock.Trigger`, `ExpandableBlock.Content`, etc). This pattern is more verbose but allows full customization over all the parts.

### With caption

Descriptor text can be optionally displayed underneath the title, either using the `caption` prop or the `ExpandableBlock.Caption` subcomponent.

<LiveExample src='ExpandableBlock.withcaption.tsx'>
  <AllExamples.ExpandableBlockWithCaptionExample client:load />
</LiveExample>

### Accordion

Expandable blocks can also stack on top of each other in an accordion to make large sets of information easier to read.

<LiveExample src='ExpandableBlock.accordion.tsx'>
  <AllExamples.ExpandableBlockAccordionExample client:load />
</LiveExample>

### With status

An expandable block could display status, an icon, or other helpful information at a glance right aligned within the block header. The status can be set using the `status` prop, and the icon can be customized using either the `endIcon` prop or the `ExpandableBlock.EndIcon` subcomponent.

<LiveExample src='ExpandableBlock.status.tsx'>
  <AllExamples.ExpandableBlockStatusExample client:load />
</LiveExample>

### Small

A small expandable block is achieved by using the `size` prop.

<LiveExample src='ExpandableBlock.small.tsx'>
  <AllExamples.ExpandableBlockSmallExample client:load />
</LiveExample>

### Borderless

The borderless expandable block is useful in tighter areas where using a default expandable block would visibly cause too many blocks. The borderless expandable block is achieved by using the `styleType` prop.

<LiveExample src='ExpandableBlock.borderless.tsx'>
  <AllExamples.ExpandableBlockBorderlessExample client:load />
</LiveExample>

### Disabled

An expandable block can be disabled by using the `disabled` prop.

<LiveExample src='ExpandableBlock.disabled.tsx'>
  <AllExamples.ExpandableBlockDisabledExample client:load />
</LiveExample>

## Guidelines

Expandable blocks are used to progressively disclose information. [Read this article to learn more about progressive disclosure.](https://www.nngroup.com/articles/progressive-disclosure/) Expandable blocks should not be used with flattened hierarchy or information panels. [Table](table) rows can also expand similarly to expandable block.

### Forms

Expandable blocks are used in pages to divide up content in sections, in forms for example. If each section has many fields, using expandable blocks will help alleviate the UI and prevent the user from scrolling endlessly to get to the section they are looking for.

<LiveExample src='ExpandableBlock.form.tsx'>
  <AllExamples.ExpandableBlockFormExample client:load />
</LiveExample>

### Expandable blocks vs hierarchy tree

While these two patterns may appear similar, they both fulfill a different role and are not interchangeable. Here are some tips to determine if an expandable block is what you need.

Use an expandable block when:

- You have a page with different sections all containing user-generated content that would benefit from being split up
- There is only one level of indentation possible at all times
- The content you want to be expandable varies from simple list items to more complex form components (such as text fields, buttons, etc.)

Use a [hierarchy tree](tree) when:

- You require a pattern that works with several levels of data (folder drilling)
- There are only list items in the pattern
- The hierarchy is not necessarily linear and may branch out

## Props

<PropsTable path={frontmatter.propsPath} />

## Related components

<RelatedComponents
  components={[
    { title: 'Table', url: 'table' },
    { title: 'Tree', url: 'tree' },
  ]}
/>
