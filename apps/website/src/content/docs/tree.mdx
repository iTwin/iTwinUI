---
title: Tree
description: A tree provides a hierarchial lists of data with nested expandable levels.
thumbnail: Tree
---

<p>{frontmatter.description}</p>

## Usage

A tree can be used to organize data in an application specific way, or it can be used to sort, filter, group, or search data as the user deems appropriate. To initialize the tree component, the following props are required:

- `nodeRenderer`: A render function that returns the node element, which must be memoized. We recommend this function to return the `TreeNode` component.
- `data`: An array of custom data used for [TreeNode](#treenode) inside `Tree`.
- `getNode`: A function that maps your `data` entry to `NodeData` that has all information about the node state. We recommend controlling state of expanded, selected and disabled nodes via this prop. The function must be memoized.

<LiveExample src='Tree.main.jsx'>
  <AllExamples.TreeMainExample client:load />
</LiveExample>

Each level of the tree is compressed of multiple `TreeNode` components, which can be used to display the node content. `TreeNode` must be used inside `Tree` component to correctly set node `depth` and `subNodes`.

### Subnode

The tree supports hierarchial data structures where each node can have subnodes, which can be expanded or collapsed. Subnodes allow handling nested data up to any desired depth.

Each object in the `data` array can include a `subItems` array to represent its children, enabling nested structures.

```jsx
const treeData = React.useMemo(
  () => [
    {
      id: 'Node-1',
      label: 'Node 1',
      subItems: [
        { id: 'Node-1-1', label: 'Node 1.1' },
        {
          id: 'Node-1-2',
          label: 'Node 1.2',
          subItems: [
            { id: 'Node-1-2-1', label: 'Node 1.2.1' },
            { id: 'Node-1-2-2', label: 'Node 1.2.2' },
          ],
        },
      ],
    },
    {
      id: 'Node-2',
      label: 'Node 2',
      subItems: [{ id: 'Node-2-1', label: 'Node 2.1' }],
    },
  ],
  [],
);
```

To manage expandable subnodes, a state variable is required to track each node and its expansion state.

The `onExpand` function in each `TreeNode` can be used to update the node's expansion state accordingly. This way, when a user expands or collapses a node, its expansion state is updated and the tree re-renders to reflect whether subnodes are visible.

```jsx
const onExpand = React.useCallback((nodeId, isExpanded) => {
  setExpandedNodes((prev) => ({
    ...prev,
    [nodeId]: isExpanded,
  }));
}, []);
```

For each node, the `getNode` function retrieves the current node's information, including whether it has subnodes or it is currently expanded. The information includes:

- The `subNodes` property which holds the array of the child nodes contained in the node.
- The `hasSubNodes` flag which indicates whether the node has subnodes. This is used to determine if node should be expandable.
- The `isExpanded` flag which indicates whether the node is expanded to display its subnode(s).

```jsx
const getNode = React.useCallback(
  (node) => {
    return {
      nodeId: node.id,
      node: node,
      subNodes: node.subItems,
      isExpanded: expandedNodes[node.id],
      hasSubNodes: node.subItems.length > 0,
    };
  },
  [expandedNodes],
);
```

<LiveExample src='Tree.subnodes.jsx'>
  <AllExamples.TreeSubNodesExample client:load />
</LiveExample>

### Size

There are two different sizes available. The default size should suffice for most cases. When a smaller version of the tree is needed, use `size="small"`.

<LiveExample src='Tree.small.jsx'>
  <AllExamples.TreeSmallExample client:load />
</LiveExample>

### Visibility

Each data level line may begin with an eye icon to toggle visibility. In this context, we suggest using the [Checkbox](/docs/checkbox) component with the `variant` set to `"eyeballs"` and passing it into the `checkbox` prop of the `TreeNode`.

<LiveExample src='Tree.visibility.jsx'>
  <AllExamples.TreeVisibilityExample client:load />
</LiveExample>

### Selection

The tree allows end users to select one or multiple nodes within its structure. This feature is useful for actions on specific nodes, such as editing, deleting or viewing details.

Similar to node expansion, a state variable is required to track the currently selected node. This state variable is updated via the `onSelect` callback, which is triggered whenever users select a node.

To ensure the `getNode` function updates the selection state of each node correctly, the `isSelected` flag should be set based on the node's `id`.

<LiveExample src='Tree.selection.jsx'>
  <AllExamples.TreeSelectionExample client:load />
</LiveExample>

### Virtualization

For trees with a large number of nodes, enabling virtualization can improve performance. To enable virtualization, the `enableVirtualization` property of the tree component can be set to `"true"`. When virtualization is enabled, the tree's DOM structure will change, adding a wrapper `div` to which `className` and `style` will be applied.

<LiveExample src='Tree.virtualization.jsx'>
  <AllExamples.TreeVirtualizationExample client:load />
</LiveExample>

### Expander customization

The `expander` prop in the `TreeNode` component allows for customization of the node expanders. We recommend using the `TreeNodeExpander` component with this prop to customize the appearance and behavior of the expanders. This can include features such as enabling expansion for disabled nodes, and adjusting the expander based on its state to better align with your application's design and user experience requirements.

<LiveExample src='Tree.customizeExpander.jsx'>
  <AllExamples.TreeCustomizeExpanderExample client:load />
</LiveExample>

**Note**: If `hasSubNodes` is false, the expanders will not be shown.

## Props

### TreeNode

<PropsTable path='@itwin/itwinui-react/esm/core/Tree/TreeNode.d.ts' />

### Tree

<PropsTable path='@itwin/itwinui-react/esm/core/Tree/Tree.d.ts' />
